package i4gl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;

import com.oracle.truffle.api.Assumption;
import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
import com.oracle.truffle.api.RootCallTarget;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.TruffleLanguage;
import com.oracle.truffle.api.TruffleLanguage.ContextPolicy;
import com.oracle.truffle.api.TruffleLogger;
import com.oracle.truffle.api.debug.DebuggerTags;
import com.oracle.truffle.api.dsl.NodeFactory;
import com.oracle.truffle.api.frame.FrameDescriptor;
import com.oracle.truffle.api.instrumentation.ProvidedTags;
import com.oracle.truffle.api.instrumentation.StandardTags;
import com.oracle.truffle.api.interop.InteropLibrary;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.NodeInfo;
import com.oracle.truffle.api.nodes.RootNode;
import com.oracle.truffle.api.source.Source;

import i4gl.exceptions.NotImplementedException;
import i4gl.nodes.builtin.BuiltinNode;
import i4gl.nodes.expression.ExpressionNode;
import i4gl.nodes.root.BuiltinRootNode;
import i4gl.nodes.root.ModuleRootNode;
import i4gl.nodes.root.UndefinedFunctionRootNode;
import i4gl.nodes.variables.read.ReadArgumentNode;
import i4gl.parser.FullParser;
import i4gl.runtime.context.Context;
import i4gl.runtime.context.LanguageView;

/**
 * Representation of our I4GL guest language for Truffle VM. Thanks to the
 * TruffleLanguage.Registration annotation we register this class so that
 * Truffle's PolyglotEngine will use our language.
 */
@TruffleLanguage.Registration(id = I4GLLanguage.ID, name = "I4GLLanguage", defaultMimeType = I4GLLanguage.MIME_TYPE, characterMimeTypes = I4GLLanguage.MIME_TYPE, contextPolicy = ContextPolicy.SHARED, fileTypeDetectors = I4GLFileTypeDetector.class)
@ProvidedTags({ StandardTags.CallTag.class, StandardTags.StatementTag.class, StandardTags.RootTag.class,
        StandardTags.RootBodyTag.class, StandardTags.ExpressionTag.class, DebuggerTags.AlwaysHalt.class,
        StandardTags.ReadVariableTag.class, StandardTags.WriteVariableTag.class })
public final class I4GLLanguage extends TruffleLanguage<Context> {
    public static volatile int counter;

    public static final String ID = "i4gl";
    public static final String MIME_TYPE = "application/x-i4gl";

    private static final TruffleLogger LOGGER = TruffleLogger.getLogger(ID, I4GLLanguage.class);
    private static final Source BUILTIN_SOURCE = Source.newBuilder(I4GLLanguage.ID, "", "I4GL builtin").build();

    // private static final StaticProperty ARRAY_PROPERTY = new DefaultStaticProperty("ARRAY");
    // // This field should be static final, but until we move the static object model we cannot have a
    // // SubstrateVM feature which will allow us to set the right field offsets at image build time.
    // @CompilerDirectives.CompilationFinal //
    // private static StaticShape<StaticObjectFactory> arrayShape;

    private final Assumption singleContext = Truffle.getRuntime().createAssumption("Single I4GL context.");
    private final Map<NodeFactory<? extends BuiltinNode>, RootCallTarget> builtinTargets = new ConcurrentHashMap<>();
    private final Map<String, RootCallTarget> undefinedFunctions = new ConcurrentHashMap<>();

    public I4GLLanguage() {
        counter++;
    }

    @Override
    protected Context createContext(Env environment) {
        LOGGER.fine("Creating new I4GLContext");
        return new Context(this, environment, new ArrayList<>(EXTERNAL_BUILTINS));
    }

    @Override
    protected boolean patchContext(Context context, Env newEnv) {
        context.patchContext(newEnv);
        return true;
    }

    public RootCallTarget getOrCreateUndefinedFunction(String name) {
        RootCallTarget target = undefinedFunctions.get(name);
        if (target == null) {
            target = Truffle.getRuntime().createCallTarget(new UndefinedFunctionRootNode(this, name));
            RootCallTarget other = undefinedFunctions.putIfAbsent(name, target);
            if (other != null) {
                target = other;
            }
        }
        return target;
    }

    public RootCallTarget lookupBuiltin(NodeFactory<? extends BuiltinNode> factory) {
        RootCallTarget target = builtinTargets.get(factory);
        if (target != null) {
            return target;
        }

        /*
         * The builtin node factory is a class that is automatically generated by the
         * Truffle DSL.
         * The signature returned by the factory reflects the signature of
         * the @Specialization
         *
         * methods in the builtin classes.
         */

        int argumentCount = factory.getExecutionSignature().size();
        ExpressionNode[] argumentNodes = new ExpressionNode[argumentCount];
        /*
         * Builtin functions are like normal functions, i.e., the arguments are passed
         * in as an
         * Object[] array encapsulated in I4GLArguments. A I4GLReadArgumentNode extracts
         * a parameter
         * from this array.
         */
        for (int i = 0; i < argumentCount; i++) {
            argumentNodes[i] = new ReadArgumentNode(i);
        }
        /* Instantiate the builtin node. This node performs the actual functionality. */
        BuiltinNode builtinBodyNode = factory.createNode((Object) argumentNodes);
        builtinBodyNode.addRootTag();
        /*
         * The name of the builtin function is specified via an annotation on the node
         * class.
         */
        String name = lookupNodeInfo(builtinBodyNode.getClass()).shortName();
        builtinBodyNode.setUnavailableSourceSection();

        /*
         * Wrap the builtin in a RootNode. Truffle requires all AST to start with a
         * RootNode.
         */
        BuiltinRootNode rootNode = new BuiltinRootNode(this, new FrameDescriptor(), builtinBodyNode,
                BUILTIN_SOURCE.createUnavailableSection(), name);

        /*
         * Register the builtin function in the builtin registry. Call targets for
         * builtins may be
         * reused across multiple contexts.
         */
        RootCallTarget newTarget = Truffle.getRuntime().createCallTarget(rootNode);
        RootCallTarget oldTarget = builtinTargets.put(factory, newTarget);
        if (oldTarget != null) {
            return oldTarget;
        }
        return newTarget;
    }

    public static NodeInfo lookupNodeInfo(Class<?> clazz) {
        if (clazz == null) {
            return null;
        }
        NodeInfo info = clazz.getAnnotation(NodeInfo.class);
        if (info != null) {
            return info;
        } else {
            return lookupNodeInfo(clazz.getSuperclass());
        }
    }

    /**
     * Gets source from the request, parses it and return call target that, if
     * called, executes given script in I4GL language.
     * 
     * @param request parsing request
     * @throws I4GLParseException the source cannot be parsed
     */
    @Override
    protected CallTarget parse(ParsingRequest request) throws Exception {
        LOGGER.fine("Received parse request");
        Source source = request.getSource();
        if (!request.getArgumentNames().isEmpty()) {
            throw new NotImplementedException();
        }
        LOGGER.log(Level.FINE, "Start parsing {0}", source.getPath());
        final FullParser parser = new FullParser(this, source);
        RootNode moduleRootNode = new ModuleRootNode(this, parser.getModuleName(), parser.getAllFunctions(),
                parser.getGlobalsFrameDescriptor(), parser.getModuleFrameDescriptor());
        LOGGER.log(Level.FINE, "Finish parsing {0}", source.getPath());
        return Truffle.getRuntime().createCallTarget(moduleRootNode);
    }

    @Override
    protected void initializeMultipleContexts() {
        singleContext.invalidate();
    }

    public boolean isSingleContext() {
        return singleContext.isValid();
    }

    @Override
    protected Object getLanguageView(Context context, Object value) {
        return LanguageView.create(value);
    }

    @Override
    protected boolean isVisible(Context context, Object value) {
        return !InteropLibrary.getFactory().getUncached(value).isNull(value);
    }

    @Override
    protected Object getScope(Context context) {
        return context.getFunctionRegistry().getFunctionsObject();
    }

    private static final LanguageReference<I4GLLanguage> REFERENCE = LanguageReference.create(I4GLLanguage.class);

    public static I4GLLanguage get(Node node) {
        return REFERENCE.get(node);
    }

    private static final List<NodeFactory<? extends BuiltinNode>> EXTERNAL_BUILTINS = Collections
            .synchronizedList(new ArrayList<>());

    public static void installBuiltin(NodeFactory<? extends BuiltinNode> builtin) {
        EXTERNAL_BUILTINS.add(builtin);
    }

    @TruffleBoundary
    public static TruffleLogger getLogger(Class<?> clazz) {
        return TruffleLogger.getLogger(ID, clazz);
    }


    // public static StaticProperty getArrayProperty() {
    //     return ARRAY_PROPERTY;
    // }

    // public StaticShape<StaticObjectFactory> getArrayShape() {
    //     if (arrayShape == null) {
    //         return initializeArrayShape();
    //     }
    //     return arrayShape;
    // }

    // @CompilerDirectives.TruffleBoundary
    // private StaticShape<StaticObjectFactory> initializeArrayShape() {
    //     synchronized (I4GLLanguage.class) {
    //         if (arrayShape == null) {
    //             arrayShape = StaticShape.newBuilder(this).property(ARRAY_PROPERTY, Object.class, true).build(StaticObject.class, StaticObjectFactory.class);
    //         }
    //         return arrayShape;
    //     }
    // }
}
