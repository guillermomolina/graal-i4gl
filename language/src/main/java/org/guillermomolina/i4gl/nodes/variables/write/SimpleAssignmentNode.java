package org.guillermomolina.i4gl.nodes.variables.write;

import java.util.Arrays;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.dsl.NodeChild;
import com.oracle.truffle.api.dsl.NodeField;
import com.oracle.truffle.api.dsl.NodeFields;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.dsl.TypeSystemReference;
import com.oracle.truffle.api.frame.FrameSlot;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.instrumentation.StandardTags.WriteVariableTag;
import com.oracle.truffle.api.instrumentation.Tag;
import com.oracle.truffle.api.nodes.ExplodeLoop;

import org.guillermomolina.i4gl.I4GLTypes;
import org.guillermomolina.i4gl.exceptions.NotImplementedException;
import org.guillermomolina.i4gl.nodes.ExpressionNode;
import org.guillermomolina.i4gl.nodes.statement.I4GLStatementNode;
import org.guillermomolina.i4gl.parser.types.TypeDescriptor;
import org.guillermomolina.i4gl.parser.types.compound.StringDescriptor;
import org.guillermomolina.i4gl.parser.types.primitive.IntDescriptor;
import org.guillermomolina.i4gl.parser.types.primitive.LongDescriptor;
import org.guillermomolina.i4gl.parser.types.primitive.RealDescriptor;
import org.guillermomolina.i4gl.parser.types.primitive.SmallFloatDescriptor;
import org.guillermomolina.i4gl.runtime.customvalues.CharValue;
import org.guillermomolina.i4gl.runtime.customvalues.NullValue;
import org.guillermomolina.i4gl.runtime.customvalues.RecordValue;
import org.guillermomolina.i4gl.runtime.customvalues.StringValue;
import org.guillermomolina.i4gl.runtime.customvalues.TextValue;
import org.guillermomolina.i4gl.runtime.customvalues.VarcharValue;
import org.guillermomolina.i4gl.runtime.exceptions.InvalidCastException;

/**
 * Node representing assignment to a variable of primitive type.
 *
 * This node uses specializations which means that it is not used directly but
 * completed node is generated by Truffle. {@link SimpleAssignmentNodeGen}
 */
@NodeFields({ @NodeField(name = "slot", type = FrameSlot.class),
        @NodeField(name = "typeDescriptor", type = TypeDescriptor.class), })
@NodeChild(value = "valueNode", type = ExpressionNode.class)
@TypeSystemReference(I4GLTypes.class)
public abstract class SimpleAssignmentNode extends I4GLStatementNode {

    protected abstract FrameSlot getSlot();

    protected abstract TypeDescriptor getTypeDescriptor();

    @CompilerDirectives.CompilationFinal
    private int jumps = -1;

    protected boolean isInt() {
        return getTypeDescriptor() == IntDescriptor.SINGLETON;
    }

    protected boolean isLong() {
        return getTypeDescriptor() == LongDescriptor.SINGLETON;
    }

    protected boolean isFloat() {
        return getTypeDescriptor() == SmallFloatDescriptor.SINGLETON;
    }

    protected boolean isDouble() {
        return getTypeDescriptor() == RealDescriptor.SINGLETON;
    }

    protected boolean isString() {
        return getTypeDescriptor() instanceof StringDescriptor;
    }

    @Specialization(guards = "isInt()")
    void writeInt(VirtualFrame frame, int value) {
        getFrame(frame).setInt(getSlot(), value);
    }

    @Specialization(guards = "isInt()")
    void writeInt(VirtualFrame frame, TextValue string) {
        try {
            int value = Integer.parseInt(string.toString());
            getFrame(frame).setInt(getSlot(), value);
        } catch(final NumberFormatException e) {
            throw new InvalidCastException(string, getTypeDescriptor());
        }       
    }

    @Specialization(guards = "isLong()")
    void writeLong(VirtualFrame frame, long value) {
        getFrame(frame).setLong(getSlot(), value);
    }

    @Specialization(guards = "isLong()")
    void writeLong(VirtualFrame frame, TextValue string) {
        try {
            long value = Long.parseLong(string.toString());
            getFrame(frame).setLong(getSlot(), value);
        } catch(final NumberFormatException e) {
            throw new InvalidCastException(string, getTypeDescriptor());
        }       
    }

    @Specialization(guards = "isFloat()")
    void writeFloat(VirtualFrame frame, float value) {
        getFrame(frame).setFloat(getSlot(), value);
    }

    @Specialization(guards = "isFloat()")
    void writeFloat(VirtualFrame frame, TextValue string) {
        try {
            float value = Float.parseFloat(string.toString());
            getFrame(frame).setFloat(getSlot(), value);
        } catch(final NumberFormatException e) {
            throw new InvalidCastException(string, getTypeDescriptor());
        }       
    }

    @Specialization(guards = "isDouble()")
    void writeDouble(VirtualFrame frame, double value) {
        getFrame(frame).setDouble(getSlot(), value);
    }

    @Specialization(guards = "isDouble()")
    void writeDouble(VirtualFrame frame, TextValue string) {
        try {
            double value = Double.parseDouble(string.toString());
            getFrame(frame).setDouble(getSlot(), value);
        } catch(final NumberFormatException e) {
            throw new InvalidCastException(string, getTypeDescriptor());
        }       
    }

    @Specialization
    void assignRecord(VirtualFrame frame, RecordValue record) {
        getFrame(frame).setObject(getSlot(), record.getCopy());
    }

    @Specialization(guards = "isString()")
    void assignString(VirtualFrame frame, TextValue value) {
        frame = getFrame(frame);
        Object targetObject = frame.getValue(getSlot());
        if (targetObject instanceof TextValue) {
            frame.setObject(getSlot(), value);
        } else if (targetObject instanceof CharValue) {
            CharValue target = (CharValue) targetObject;
            target.assignString(value.toString());
        } else if (targetObject instanceof VarcharValue) {
            VarcharValue target = (VarcharValue) targetObject;
            target.assignString(value.toString());
        } else {
            throw new NotImplementedException();
        }
    }

    @Specialization
    void assignNull(VirtualFrame frame, NullValue value) {
        getFrame(frame).setObject(getSlot(), value);
    }

    @Specialization
    void assignIntArray(VirtualFrame frame, int[] array) {
        getFrame(frame).setObject(getSlot(), Arrays.copyOf(array, array.length));
    }

    @Specialization
    void assignLongArray(VirtualFrame frame, long[] array) {
        getFrame(frame).setObject(getSlot(), Arrays.copyOf(array, array.length));
    }

    @Specialization
    void assignFloatArray(VirtualFrame frame, float[] array) {
        getFrame(frame).setObject(getSlot(), Arrays.copyOf(array, array.length));
    }

    @Specialization
    void assignDoubleArray(VirtualFrame frame, double[] array) {
        getFrame(frame).setObject(getSlot(), Arrays.copyOf(array, array.length));
    }

    /**
     * This is used for multidimensional arrays
     */
    @Specialization
    void assignArray(VirtualFrame frame, Object[] array) {
        getFrame(frame).setObject(getSlot(), Arrays.copyOf(array, array.length));
    }

    @Specialization
    void assignArray(VirtualFrame frame, StringValue array) {
        getFrame(frame).setObject(getSlot(), array.createDeepCopy());
    }

    @ExplodeLoop
    private VirtualFrame getFrame(VirtualFrame frame) {
        if (jumps == -1) {
            jumps = this.getJumpsToFrame(frame, getSlot());
            CompilerDirectives.transferToInterpreterAndInvalidate();
        }

        for (int i = 0; i < jumps; ++i) {
            frame = (VirtualFrame) frame.getArguments()[0];
        }

        return frame;
    }

    @Override
    public boolean hasTag(Class<? extends Tag> tag) {
        return tag == WriteVariableTag.class || super.hasTag(tag);
    }
}
